//Set the initial values of variables
int onoffSwitch = 0;
const int onoffSwitchPin = 5;

int limSwitch = 0; // This will read 1/HIGH when clicked
const int limSwitchPin = 13;

int ENApin = 10;  // set enable pin A
int IN1pin = 11;  // set to IN1
int IN2pin = 12;  // set to IN2

volatile long motorPosition = 0; // [encoder counts] Current motor position
//Declared 'volatile' since it is updated in a function called by interrupts
volatile int encoderStatus = 0; // [binary] Past and current

// Pin Assignment
const int PIN_NR_ENCODER_A = 2; // Never change these, since the interrupts are attached to pin 2 and 3
const int PIN_NR_ENCODER_B = 3; // Never change these, since the interrupts are attached to pin 2 and 3

// Constants for motor control
const int upperLim = 1950;
const int speed = 150;
int state = 1;
// state 1 means calibrate, state 2 moves to blue buttons, 3 goes to red, and 4 goes to yellow. 5 means wait

void setup() {
  // For On/Off Switch
  pinMode (onoffSwitchPin, INPUT);
  Serial.begin(115200);
  Serial.println("Start");

  // For Limit Switch
  pinMode(limSwitchPin,INPUT);

  // For Motor
  pinMode(ENApin, OUTPUT);  // set all pins going to Hbridge to output
  pinMode(IN1pin, OUTPUT);
  pinMode(IN2pin, OUTPUT);

  // For Encoder
  pinMode(PIN_NR_ENCODER_A, INPUT);
  pinMode(PIN_NR_ENCODER_B, INPUT);
  // Turn on the the pullup resistors on the encoder channels
  digitalWrite(PIN_NR_ENCODER_A, HIGH);
  digitalWrite(PIN_NR_ENCODER_B, HIGH);
  // Activate interrupt for encoder pins.
  // If either of the two pins changes, the function 'updateMotorPosition' is called:
  attachInterrupt(0, updateMotorPosition, CHANGE); // Interrupt 0 is always attached to digital pin 2
  attachInterrupt(1, updateMotorPosition, CHANGE); // Interrupt 1 is always attached to digital pin 3
  Serial.println("Start");
}

void loop() {
  // Constantly check the switch state
  onoffSwitch = digitalRead(onoffSwitchPin);
  // Read the limit switch and assign readings to variables
  limSwitch = digitalRead(limSwitchPin);
  if (onoffSwitch == HIGH) {
    runMotor();
  } else {
    shutDownMotor();
  }

  // Print encoder counts to serial monitor
  Serial.print("The motor position is ");
  Serial.println(motorPosition);
}

void runMotor() {
  switch (state) {
    case 1:
      counterclockwise();
      if (calibrate()) {
        state = 2;
      }
      break;
    case 2:
      clockwise();
      if (checkUpperLim()) {
        state = 1;
      }
      break;
  }
  // if (checkSwitch()) return;
  // // Serial.println("Switch on");  
  // if (calibrate()) { // 
  //   clockwise();
  // }
  // if (checkUpperLim()) {
  //   analogWrite(ENApin, speed);
  //   digitalWrite(IN1pin, HIGH);
  //   digitalWrite(IN2pin, LOW);
  // }
}

void shutDownMotor() {
  // Serial.println("Switch off");
  digitalWrite(ENApin, HIGH);
  digitalWrite(IN1pin, HIGH);
  digitalWrite(IN2pin, HIGH);
}

bool checkSwitch() {
  onoffSwitch = digitalRead(onoffSwitchPin);
  if (onoffSwitch == LOW) {
    shutDownMotor();
    return true;
  } 
  return false;
}

bool calibrate() { // this is state 1
  if (limSwitch == HIGH){
    motorPosition = 0;
    return true;
  } 
  return false;
}

bool checkUpperLim() {
  if (motorPosition > upperLim) {
      Serial.println("SHUT DOWN MOTOR");
      shutDownMotor();
      return true;
  }
  return false;
}

void counterclockwise() {
  analogWrite(ENApin, speed);
  // digitalWrite(ENApin, HIGH);
  digitalWrite(IN1pin, HIGH);
  digitalWrite(IN2pin, LOW);
}

void clockwise() {
  analogWrite(ENApin, speed);
  // digitalWrite(ENApin, HIGH);
  digitalWrite(IN1pin, LOW);
  digitalWrite(IN2pin, HIGH);
}

void updateMotorPosition() {
  // Bitwise shift left by one bit, to make room for a bit of new data:
  encoderStatus <<= 1;
  // Use a compound bitwise OR operator (|=) to read the A channel of the encoder (pin 2)
  // and put that value into the rightmost bit of encoderStatus:
  encoderStatus |= digitalRead(2);
  // Bitwise shift left by one bit, to make room for a bit of new data:
  encoderStatus <<= 1;
  // Use a compound bitwise OR operator (|=) to read the B channel of the encoder (pin 3)
  // and put that value into the rightmost bit of encoderStatus
  encoderStatus |= digitalRead(3);
  // encoderStatus is truncated to only contain the rightmost 4 bits by using a
  // bitwise AND operator on encoderStatus and 15 (0b1111);
  encoderStatus &= 15;
  if (encoderStatus==2 || encoderStatus==4 || encoderStatus==11 || encoderStatus==13) {
    // the encoder status matches a bit pattern that requires counting up by one
    motorPosition--;  // increase the encoder count by one
  } else { // the encoder status does not match a bit pattern that requires counting up by one.
    // Since this function is only called if something has changed, we have to count downwards
    motorPosition++;  // decrease the encoder count by one
  }
}
