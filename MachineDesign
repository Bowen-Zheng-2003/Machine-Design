//////////////////////////////////////////////
// DEFINE CONSTANTS AND GLOBAL VARIABLES:   //
//////////////////////////////////////////////
//** State Machine: **//
// CONSTANTS: 
// Definition of states in the state machine
const int CALIBRATE     = 1;
const int FIRST_BUTTON  = 2;
const int SECOND_BUTTON = 3;
const int THIRD_BUTTON  = 4;
const int WAIT = 5;
// VARIABLES:
// Global variable that keeps track of the state:
// Start the state machine in calibration state:
int  state = CALIBRATE;
int old_state = CALIBRATE;

//** Computation of position and velocity: **//
// CONSTANTS: 
// Settings for velocity computation:
const int  MIN_VEL_COMP_COUNT = 2;     // [encoder counts] Minimal change in motor position that must happen between two velocity measurements
const long MIN_VEL_COMP_TIME  = 10000; // [microseconds] Minimal time that must pass between two velocity measurements
// VARIABLES:
volatile int motorPosition = 0; // [encoder counts] Current motor position (Declared 'volatile', since it is updated in a function called by interrupts)
volatile int encoderStatus = 0; // [binary] Past and Current A&B values of the encoder  (Declared 'volatile', since it is updated in a function called by interrupts)
// The rightmost two bits of encoderStatus will store the encoder values from the current iteration (A and B).
// The two bits to the left of those will store the encoder values from the previous iteration (A_old and B_old).
float motorVelocity        = 0; // [encoder counts / seconds] Current motor velocity 
int previousMotorPosition  = 0; // [encoder counts] Motor position the last time a velocity was computed 
long previousVelCompTime   = 0; // [microseconds] System clock value the last time a velocity was computed 
const int speed = 100;

//** High-level behavior of the controller:  **//
// CONSTANTS:
// Target positions:
const int CALIBRATION_VOLTAGE     =  0;                 // [Volt] Motor voltage used during the calibration process
const int FIRST_BUTTON_POSITION   =  -100;                 // [encoder counts] Motor position corresponding to first button position
const int SECOND_BUTTON_POSITION  =  650;                 // [encoder counts] Motor position corresponding to second button position
const int THIRD_BUTTON_POSITION   =  1750;                 // [encoder counts] Motor position corresponding to third button position
const int LOWER_BOUND = 0;              // [encoder counts] Position of the left end stop
const int UPPER_BOUND = THIRD_BUTTON_POSITION;  // [encoder counts] Position of the right end stop
const int TARGET_BAND = 5;                      // [encoder counts] "Close enough" range when moving towards a target.
// Timing:
const long  WAIT_TIME = 1000000; // [microseconds] Time waiting at each location
// VARIABLES:
unsigned long startWaitTime; // [microseconds] System clock value at the moment the WAIT state started

//** PID Controller  **//
// CONSTANTS:
const float KP             = 0;  // [Volt / encoder counts] P-Gain
const float KD             = 0;  // [Volt * seconds / encoder counts] D-Gain
const float KI             = 0; // [Volt / (encoder counts * seconds)] I-Gain
const float SUPPLY_VOLTAGE = 12.0;  // [Volt] Supply voltage at the HBridge
const float BASE_CMD       = 0;   // [Volt] Voltage needed to overcome friction
// VARIABLES:
int  targetPosition  = 0;   // [encoder counts] desired motor position
float positionError  = 0;   // [encoder counts] Position error
float integralError  = 0;   // [encoder counts * seconds] Integrated position error
float velocityError  = 0;   // [encoder counts / seconds] Velocity error
float desiredVoltage = 0;   // [Volt] Desired motor voltage
int   motorCommand   = 0;   // [0-255] PWM signal sent to the motor
unsigned long executionDuration = 0;  // [microseconds] Time between this and the previous loop execution.  Variable used for integrals and derivatives
unsigned long lastExecutionTime = 0;  // [microseconds] System clock value at the moment the loop was started the last time

// Gravity Compensation Lookup Table: 
// CONSTANTS: 
const float FF_BALANCED_POSITION   = 0;  // [encoder counts] Position at which the device is fully balanced. 
const float FF_VOLTAGE_LOWER_BOUND = 0; // [Volt] Voltage to be applied at the left endstop 
const float FF_VOLTAGE_UPPER_BOUND = 0; // [Volt] Voltage to be applied at the right endstop 

//** Pin assignment: **//
// CONSTANTS:
const int PIN_NR_ENCODER_A        = 2;  // Never change these, since the interrupts are attached to pin 2 and 3
const int PIN_NR_ENCODER_B        = 3;  // Never change these, since the interrupts are attached to pin 2 and 3
const int PIN_NR_ON_OFF_SWITCH    = 5;
const int PIN_NRL_LIMIT_SWITCH    = 8;
const int PIN_NR_PWM_OUTPUT       = 10;  // ENA on the H-bridge
const int PIN_NR_PWM_DIRECTION_1  = 11;  // IN1 on the H-bridge
const int PIN_NR_PWM_DIRECTION_2  = 12;  // IN2 on the H-bridge
// End of CONSTANTS AND GLOBAL VARIABLES

int onoffSwitch = 0;
// const int onoffSwitchPin = 5;

int limSwitch = 0; // This will read 1/HIGH when clicked
// const int limSwitchPin = 13;

// int ENApin = 10;  // set enable pin A
// int IN1pin = 11;  // set to IN1
// int IN2pin = 12;  // set to IN2

// // Pin Assignment
// const int PIN_NR_ENCODER_A = 2; // Never change these, since the interrupts are attached to pin 2 and 3
// const int PIN_NR_ENCODER_B = 3; // Never change these, since the interrupts are attached to pin 2 and 3

void setup() {
  // For On/Off Switch
  pinMode (PIN_NR_ON_OFF_SWITCH, INPUT);
  Serial.begin(115200);
  Serial.println("Start");
  
  // For Limit Switch
  pinMode(PIN_NRL_LIMIT_SWITCH, INPUT);

  // For Motor
  pinMode(PIN_NR_PWM_OUTPUT, OUTPUT);  // set all pins going to Hbridge to output
  pinMode(PIN_NR_PWM_DIRECTION_1, OUTPUT);
  pinMode(PIN_NR_PWM_DIRECTION_2, OUTPUT);

  // For Encoder
  pinMode(PIN_NR_ENCODER_A, INPUT);
  pinMode(PIN_NR_ENCODER_B, INPUT);
  // Turn on the the pullup resistors on the encoder channels
  digitalWrite(PIN_NR_ENCODER_A, HIGH);
  digitalWrite(PIN_NR_ENCODER_B, HIGH);
  // Activate interrupt for encoder pins.
  // If either of the two pins changes, the function 'updateMotorPosition' is called:
  attachInterrupt(0, updateMotorPosition, CHANGE); // Interrupt 0 is always attached to digital pin 2
  attachInterrupt(1, updateMotorPosition, CHANGE); // Interrupt 1 is always attached to digital pin 3
  Serial.println("Start");
}

void loop() {
  // Constantly check the switch state
  onoffSwitch = digitalRead(PIN_NR_ON_OFF_SWITCH);
  // Read the limit switch and assign readings to variables
  limSwitch = digitalRead(PIN_NRL_LIMIT_SWITCH);
  if (onoffSwitch == HIGH) {
    runMotor();
  } else {
    shutDownMotor();
  }

  // Print encoder counts to serial monitor
  Serial.print("The motor position is ");
  Serial.println(motorPosition);
}

void runMotor() {
  switch (state) {
    case CALIBRATE:
      counterclockwise();
      if (calibrate()) {
        state = FIRST_BUTTON;
        delay(1000);
      }
      break;
    case FIRST_BUTTON:
      if (motorPosition >= FIRST_BUTTON_POSITION){
        shutDownMotor();
        // Serial.println("You're at the FIRST BUTTON");
        state = SECOND_BUTTON;
        delay(1000);
      }
      else if (motorPosition < FIRST_BUTTON_POSITION) {
        clockwise();
      }
      break;
    case SECOND_BUTTON:
      if (motorPosition >= SECOND_BUTTON_POSITION) {
        shutDownMotor();
        // Serial.println("You're at the SECOND BUTTON");
        state = THIRD_BUTTON;
        delay(1000);
      }
      else if (motorPosition < SECOND_BUTTON_POSITION) {
        clockwise();
      }
      break;
    case THIRD_BUTTON:
      if (motorPosition >= THIRD_BUTTON_POSITION) {
        shutDownMotor();
        // Serial.println("You're at the THIRD BUTTON");
        state = WAIT;
        delay(1000);
      }
      else if (motorPosition < THIRD_BUTTON_POSITION) {
        clockwise();
      }
      break;
    case WAIT: // DONT USE THIS!!
      shutDownMotor();
      break;
  }
}

void shutDownMotor() {
  // Serial.println("Switch off");
  digitalWrite(PIN_NR_PWM_OUTPUT, HIGH);
  digitalWrite(PIN_NR_PWM_DIRECTION_1, HIGH);
  digitalWrite(PIN_NR_PWM_DIRECTION_2, HIGH);
}

bool checkSwitch() {
  onoffSwitch = digitalRead(PIN_NR_ON_OFF_SWITCH);
  if (onoffSwitch == LOW) {
    shutDownMotor();
    return true;
  } 
  return false;
}

bool calibrate() { // this is state 1
  if (limSwitch == HIGH){
    motorPosition = 0;
    return true;
  } 
  return false;
}

bool checkUpperLim() {
  if (motorPosition > THIRD_BUTTON) {
      Serial.println("SHUT DOWN MOTOR");
      shutDownMotor();
      return true;
  }
  return false;
}

void counterclockwise() {
  analogWrite(PIN_NR_PWM_OUTPUT, speed);
  // digitalWrite(ENApin, HIGH);
  digitalWrite(PIN_NR_PWM_DIRECTION_1, HIGH);
  digitalWrite(PIN_NR_PWM_DIRECTION_2, LOW);
}

void clockwise() {
  analogWrite(PIN_NR_PWM_OUTPUT, speed);
  // digitalWrite(ENApin, HIGH);
  digitalWrite(PIN_NR_PWM_DIRECTION_1, LOW);
  digitalWrite(PIN_NR_PWM_DIRECTION_2, HIGH);
}

void updateMotorPosition() {
  // Bitwise shift left by one bit, to make room for a bit of new data:
  encoderStatus <<= 1;
  // Use a compound bitwise OR operator (|=) to read the A channel of the encoder (pin 2)
  // and put that value into the rightmost bit of encoderStatus:
  encoderStatus |= digitalRead(2);
  // Bitwise shift left by one bit, to make room for a bit of new data:
  encoderStatus <<= 1;
  // Use a compound bitwise OR operator (|=) to read the B channel of the encoder (pin 3)
  // and put that value into the rightmost bit of encoderStatus
  encoderStatus |= digitalRead(3);
  // encoderStatus is truncated to only contain the rightmost 4 bits by using a
  // bitwise AND operator on encoderStatus and 15 (0b1111);
  encoderStatus &= 15;
  if (encoderStatus==2 || encoderStatus==4 || encoderStatus==11 || encoderStatus==13) {
    // the encoder status matches a bit pattern that requires counting up by one
    motorPosition--;  // increase the encoder count by one
  } else { // the encoder status does not match a bit pattern that requires counting up by one.
    // Since this function is only called if something has changed, we have to count downwards
    motorPosition++;  // decrease the encoder count by one
  }
}
